use anyhow::Result;
use serde::Serialize;

/// Markdown badges i.e. a small image (generated by shields.io)
/// linked to a website In this case, badges linked to docs.rs,
/// crates.io, github, and lib.rs
pub(super) static CRATE_BLOCK_BADGES: &str = concat!(
    "{{ if homepage_defined }}[![{crate_name}~website][c~{crate_name | underscored}~website~badge]][c~{crate_name | underscored}~website] {{ endif }}",
    "[![{crate_name}][c~{crate_name | underscored}~docs~badge]][c~{crate_name | underscored}~docs] ",
    "[![{crate_name}~crates.io][c~{crate_name | underscored}~crates.io~badge]][c~{crate_name | underscored}~crates.io] ",
    "[![{crate_name}~github][c~{crate_name | underscored}~github~badge]][c~{crate_name | underscored}~github] ",
    r"[![{crate_name}~lib.rs][c~{crate_name | underscored}~lib.rs~badge]][c~{crate_name | underscored}~lib.rs]\{\{hi:{crate_name}}} "
);

pub(super) static CRATE_DESCRIPTION: &str =
    "{{- if description_defined }}{description}{{ endif -}}";

/// Reference definitions for the badges above
pub(super) static CRATE_BLOCK_REFDEFS: &str = "\
[c~{crate_name | underscored}~docs~badge]: https://img.shields.io/crates/v/{crate_name}?label={crate_name}
[c~{crate_name | underscored}~crates.io~badge]: https://img.shields.io/badge/crates.io-{crate_name | shielded}-crimson
[c~{crate_name | underscored}~crates.io]: https://crates.io/crates/{crate_name | underscored}
[c~{crate_name | underscored}~github~badge]: https://img.shields.io/badge/{crate_name | shielded}-steelblue?logo=github
{{ if repository_defined }}[c~{crate_name | underscored}~github]: {repository}{{ endif }}
[c~{crate_name | underscored}~lib.rs~badge]: https://img.shields.io/badge/lib.rs-{crate_name | shielded}-yellow
[c~{crate_name | underscored}~lib.rs]: https://lib.rs/crates/{crate_name}
[c~{crate_name | underscored}~docs]: {{ if documentation_defined }}{documentation}{{ else }}https://docs.rs/{crate_name}{{ endif }}
{{ if homepage_defined }}[c~{crate_name | underscored}~website~badge]: https://img.shields.io/badge/{crate_name | shielded}-coral{{ endif }}
{{ if homepage_defined }}[c~{crate_name | underscored}~website]: {homepage}{{ endif }}
";

/// The different modes for generating content related to a crate.
///
/// This enum defines the different types of content that can be generated for a crate, such as badges, description, and reference definitions.
pub enum GenerationMode {
    CrateBlock,
    CrateDescription,
    CrateBlockRefdefs,
}

/// Generates crate block badges, description, or reference definitions based on the provided crate data and generation mode.
///
/// # Arguments
///
/// * `crate_data` - A reference to the `crates_io_api::Crate` struct containing information about the crate.
pub fn create_crate_block_badges_or_refdefs(
    crate_data: &crates_io_api::Crate,
    mode: GenerationMode,
) -> Result<String> {
    use trim_in_place::TrimInPlace;

    use super::normalize_url::normalize_docs_url;

    let tt = super::get_template_engine()?;

    // Normalize URL
    let documentation = crate_data
        .documentation
        .as_ref()
        .map(|s| normalize_docs_url(s))
        .unwrap_or_default();

    #[derive(Serialize)]
    /// Context data used for rendering templates.
    struct Context<'a> {
        crate_name: &'a str,
        description_defined: bool,
        description: &'a str,
        documentation_defined: bool,
        documentation: &'a str, // URL e.g. https://docs.rs/{crate}
        homepage_defined: bool,
        homepage: &'a str, /* URL e.g. https://github.com/sollimann/bonsai, https://serde.rs */
        repository_defined: bool,
        repository: String, // URL e.g. https://github.com/serde-rs/serde
    }

    let context = Context {
        crate_name: &crate_data.name.to_lowercase(),
        description_defined: crate_data.description.is_some(),
        description: crate_data.description.as_deref().unwrap_or_default(),
        documentation_defined: crate_data.documentation.is_some(),
        documentation: documentation.trim_end_matches('/'),
        homepage_defined: crate_data.homepage.is_some()
            && (crate_data.homepage != crate_data.repository),
        homepage: crate_data
            .homepage
            .as_deref()
            .unwrap_or_default()
            .trim_end_matches('/'),
        repository_defined: crate_data.repository.is_some(),
        repository: crate_data
            .repository
            .as_deref()
            .unwrap_or_default()
            .replace(".git", "")
            .trim_end_matches('/')
            .to_string(),
    };
    let mut rendered = match mode {
        GenerationMode::CrateBlock => tt.render("CRATE_BLOCK_BADGES", &context)?,
        GenerationMode::CrateDescription => tt.render("CRATE_DESCRIPTION", &context)?,
        GenerationMode::CrateBlockRefdefs => tt.render("CRATE_BLOCK_REFDEFS", &context)?,
    };
    rendered.trim_in_place();
    Ok(rendered)
}

/// Capitalizes the first letter of a string if it is not equal to another string.
///
/// # Arguments
///
/// * `s` - The string to capitalize.
/// * `should_not_be` - The string that `s` should not be equal to.
fn capitalize_if_not(s: String, should_not_be: &str) -> String {
    if s != should_not_be {
        let mut c = s.chars();
        match c.next() {
            None => String::new(),
            Some(f) => f.to_uppercase().collect::<String>() + c.as_str(),
        }
    } else {
        s
    }
}

/// Creates a "crate block" for a given crate, which includes several badges linking to various crate websites; associated keywords, categories; crate description,
/// and reference definitions for all links.
///
/// # Arguments
///
/// * `name` - The name of the crate.
///
/// Returns the crate block as a `String`.
/// Also return the reference definitions as a separate vector of strings.
pub fn create_crate_block(name: &str) -> Result<(String, Vec<String>)> {
    use anyhow::Context;

    let mut crate_block = String::new();

    let info = crate::get_info_for_crate(name).with_context(|| format!("Unknown crate: {name}"))?;

    let badges =
        create_crate_block_badges_or_refdefs(&info.crate_data, GenerationMode::CrateBlock)?;
    crate_block.push_str(&badges);

    // Add index entries for keywords.
    let keywords: Vec<_> = info
        .keywords
        .into_iter()
        .map(|k| capitalize_if_not(k.keyword, name))
        .collect();
    let kws = keywords.iter().map(String::as_str).collect();
    let markdown = super::create_index_anchors(kws)?;
    crate_block.push_str(&markdown);

    // Print category badges.
    for cat in info.categories {
        let markdown = super::create_category_badge(&cat.category, &cat.slug)?;
        crate_block.push_str(&markdown);
    }
    crate_block.push_str("\n\n");

    let desc =
        create_crate_block_badges_or_refdefs(&info.crate_data, GenerationMode::CrateDescription)?;
    if !desc.is_empty() {
        crate_block.push_str(&(format!("{desc}\n\n")));
    }

    let refdefs =
        create_crate_block_badges_or_refdefs(&info.crate_data, GenerationMode::CrateBlockRefdefs)?;
    crate_block.push_str(&refdefs);

    // Also return the refdefs as a separate vector of strings.
    let vector_of_lines: Vec<String> = refdefs.split('\n').map(|str| str.to_string()).collect();

    Ok((crate_block, vector_of_lines))
}
