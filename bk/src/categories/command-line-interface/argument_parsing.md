# Command-line argument parsing

{{#include argument_parsing.incl.md}}

## Using clap's builder API {#clap-builder}

[![clap][c-clap-badge]][c-clap]{{hi:clap}} [![clap-examples][c-clap-examples-badge]][c-clap-examples] [![clap-github][c-clap-github-badge]][c-clap-github] [![cat-command-line-interface][cat-command-line-interface-badge]][cat-command-line-interface]{{hi:Command-line interface}}

This application describes the structure of its command-line interface using [`clap`][c-clap]{{hi:clap}}⮳'s builder style. The [documentation][c-clap]{{hi:clap}}⮳ gives two other possible ways to instantiate an application.

In the builder style, `with_name` is the unique identifier that `value_of` will use to retrieve the value passed. The [`clap::Arg::short`][c-clap::Arg::short]{{hi:clap::Arg::short}}⮳ and [`clap::Arg::long`][c-clap::Arg::long]{{hi:clap::Arg::long}}⮳ options control the flag{{hi:Flag}} the user will be expected to type; short flags look like `-f` and long flags look like `--file`.

```rust,editable
{{#include ../../../crates/cats/command_line_interface/tests/arguments/clap_basic.rs:example}}
```

Usage information is generated by [`clap`][c-clap]{{hi:clap}}⮳. The usage for the example application looks like this.

```bash
My Test Program 0.1.0
Hackerman Jones <hckrmnjones@hack.gov>
Teaches argument parsing

USAGE:
  testing [OPTIONS]

FLAGS:
  -h, --help    Prints help information.
  -V, --version  Prints version information.

OPTIONS:
  -f, --file <file>   A cool file.
  -n, --number <num>  Five less than your favorite number.
```

We can test the application by running a command like the following.

```bash
cargo run -- -f myfile.txt -n 251
```

The output is:

```bash
The file passed is: myfile.txt
Your favorite number must be 256.
```

## Using `clap`'s derive API {#clap-derive}

[![clap][c-clap-badge]][c-clap]{{hi:clap}} [(tutorial)][c-clap-tutorial] [(cookbook)][c-clap-cookbook] [![clap examples][c-clap-examples-badge]][c-clap-examples] [![cat-command-line-interface][cat-command-line-interface-badge]][cat-command-line-interface]{{hi:Command-line interface}}

[`clap_derive`][c-clap_derive]⮳{{hi:clap_derive}} simplifies CLI creation in Rust via a [`derive`][c-derive]⮳{{hi:derive}} macro, automatically generating command-line argument parsing logic from `struct` definitions.

```rust,editable
{{#include ../../../crates/cats/command_line_interface/tests/arguments/clap.rs:example}}
```

## See also

### `lexopt` {#lexopt}

[![lexopt][c-lexopt-badge]][c-lexopt]{{hi:lexopt}}
[![lexopt-crates.io][c-lexopt-crates.io-badge]][c-lexopt-crates.io]
[![lexopt-github][c-lexopt-github-badge]][c-lexopt-github]
[![lexopt-lib.rs][c-lexopt-lib.rs-badge]][c-lexopt-lib.rs]

[`lexopt`][c-lexopt]⮳{{hi:lexopt}} offers efficient and ergonomic command-line argument parsing. It prioritizes simplicity and performance with a declarative approach, avoiding complex macros. Expect fast compile times, fast runtime, but a tool pedantic about correctness. Its API is less ergonomic.

```rust,editable
{{#include ../../../crates/cats/command_line_interface/tests/arguments/lexopt.rs:example}}
```

### Parse command-line arguments with `pico-args` {#pico-args}

[![pico-args][c-pico_args-badge]][c-pico_args]{{hi:pico-args}}
[![pico-args-crates.io][c-pico_args-crates.io-badge]][c-pico_args-crates.io]
[![pico-args-github][c-pico_args-github-badge]][c-pico_args-github]
[![pico-args-lib.rs][c-pico_args-lib.rs-badge]][c-pico_args-lib.rs]

The [`pico-args`][c-pico_args]⮳{{hi:pico-args}} crate is a small and fast library for parsing command-line arguments in Rust.

[`pico-args`][c-pico_args]⮳{{hi:pico-args}} is tiny, dependency-free, and designed for extremely fast and minimal command-line argument parsing. It focuses on speed and small binary size, making it suitable for resource-constrained environments or applications where performance is critical. It offers a simple API for basic argument parsing but may not be as feature-rich as larger crates. Note the following:

- No help generation.
- Only flags, options, free arguments and subcommands are supported.
- No combined flags (like -vvv or -abc).
- Options can be separated by a space, = (with the `eq-separator` feature) or nothing.
- Arguments can be in any order.
- Non UTF-8 arguments are supported.
- Ergonomic API.

```rust,editable
{{#include ../../../crates/cats/command_line_interface/tests/arguments/pico_args.rs:example}}
```

### `structopt` {#structopt}

[![structopt][c-structopt-badge]][c-structopt] [![structopt-crates.io][c-structopt-crates.io-badge]][c-structopt-crates.io] [![structopt-github][c-structopt-github-badge]][c-structopt-github] [![structopt-lib.rs][c-structopt-lib.rs-badge]][c-structopt-lib.rs]{{hi:structopt}}{{hi:Docopt}}{{hi:Clap}}{{hi:Derive}}{{hi:Cli}} [![cat-command-line-interface][cat-command-line-interface-badge]][cat-command-line-interface]{{hi:Command-line interface}}

[`structopt`][c-structopt]⮳{{hi:structopt}} parses command line arguments by defining a `struct`.

[`structopt`][c-structopt]⮳{{hi:structopt}} (now superseded by [`clap`][c-clap]⮳{{hi:clap}}) simplifies command-line argument parsing by automatically generating parsers from struct definitions. It leverages a derive macro to reduce boilerplate and provides a declarative way to define CLI options, arguments, and subcommands, making it easier to create complex and well-documented command-line interfaces.

## Related Topics {#skip}

- [[parse | Parse]].
- [[parser-implementations | Parser Implementations]].
- [[parsing | Parsing]].
- [[string_parsing | String Parsing]].

{{#include refs.incl.md}}
{{#include ../../refs/link-refs.md}}

<div class="hidden">
[arguments: expand `lexopt` and `pico-args`](https://github.com/john-cd/rust_howto/issues/233)

### Argument parsing {#skip1}

- [Parsing arguments in Rust, without using dependencies][parsing-arguments-rust-no-dep-blog].

---

## `clap_complete` {#clap_complete}

Generate shell completion scripts for your `clap::Command`
</div>
