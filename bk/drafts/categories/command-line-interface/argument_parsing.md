# Command-line Argument Parsing

{{#include argument_parsing.incl.md}}

## Using `clap`'s Builder API {#clap-builder}

[![clap][c~clap~docs~badge]][c~clap~docs]{{hi:clap}} [![clap~examples][c~clap~examples~badge]][c~clap~examples] [![clap~github][c~clap~github~badge]][c~clap~github] [![cat~command-line-interface][cat~command-line-interface~badge]][cat~command-line-interface]{{hi:Command-line interface}}

This application describes the structure of its command-line interface using [`clap`][c~clap~docs]{{hi:clap}}↗'s builder style. The [documentation][c~clap~docs]{{hi:clap}}↗ gives two other possible ways to instantiate an application.

In the builder style, `with_name`{{hi:with_name}} is the unique identifier that `value_of`{{hi:value_of}} will use to retrieve the value passed. The [`clap::Arg::short`][c~clap::Arg::short~docs]{{hi:clap::Arg::short}}↗ and [`clap::Arg::long`][c~clap::Arg::long~docs]{{hi:clap::Arg::long}}↗ options control the flag{{hi:Flag}} the user will be expected to type; short flags look like `-f` and long flags look like `--file`.

```rust,editable
{{#include ../../../crates/cats/command_line_interface/examples/arguments/clap_basic.rs:example}}
```

Usage information is generated by [`clap`][c~clap~docs]{{hi:clap}}↗. The usage for the example application looks like this.

```bash
My Test Program 0.1.0
Hackerman Jones <hckrmnjones@hack.gov>
Teaches argument parsing

USAGE:
  testing [OPTIONS]

FLAGS:
  -h, --help    Prints help information.
  -V, --version  Prints version information.

OPTIONS:
  -f, --file <file>   A cool file.
  -n, --number <num>  Five less than your favorite number.
```

We can test the application by running a command like the following.

```bash
cargo run -- -f myfile.txt -n 251
```

The output is:

```bash
The file passed is: myfile.txt
Your favorite number must be 256.
```

## Using `clap`'s Derive API {#clap-derive}

[![clap][c~clap~docs~badge]][c~clap~docs]{{hi:clap}} [(tutorial)][c~clap~tutorial] [(cookbook)][c~clap~cookbook] [![clap examples][c~clap~examples~badge]][c~clap~examples] [![cat~command-line-interface][cat~command-line-interface~badge]][cat~command-line-interface]{{hi:Command-line interface}}

[`clap_derive`][c~clap_derive~docs]↗{{hi:clap_derive}} simplifies CLI creation in Rust via a [`derive`][c~derive~docs]↗{{hi:derive}} macro, automatically generating command-line argument parsing logic from [`struct`](https://doc.rust-lang.org/std/keyword.struct.html)↗{{hi:struct}} definitions.

```rust,editable
{{#include ../../../crates/cats/command_line_interface/examples/arguments/clap.rs:example}}
```

## Generate Shell Completion Scripts with `clap_complete` {#clap_complete}

[![clap_complete][c~clap_complete~docs~badge]][c~clap_complete~docs] [![clap_complete~crates.io][c~clap_complete~crates.io~badge]][c~clap_complete~crates.io] [![clap_complete~github][c~clap_complete~github~badge]][c~clap_complete~github] [![clap_complete~lib.rs][c~clap_complete~lib.rs~badge]][c~clap_complete~lib.rs]{{hi:clap_complete}}{{hi:Bash}}{{hi:Clap}}{{hi:Cli}}{{hi:Completion}} [![cat~command-line-interface][cat~command-line-interface~badge]][cat~command-line-interface]{{hi:Command-line interface}}

`clap_complete` generates shell completion scripts for your `clap::Command`.

## `clap` Alternatives {#skip}

### Parse Command-line Arguments with `lexopt` {#lexopt}

[![lexopt][c~lexopt~docs~badge]][c~lexopt~docs]{{hi:lexopt}}
[![lexopt~crates.io][c~lexopt~crates.io~badge]][c~lexopt~crates.io]
[![lexopt~github][c~lexopt~github~badge]][c~lexopt~github]
[![lexopt~lib.rs][c~lexopt~lib.rs~badge]][c~lexopt~lib.rs]

[`lexopt`][c~lexopt~docs]↗{{hi:lexopt}} offers efficient and ergonomic command-line argument parsing. It prioritizes simplicity and performance with a declarative approach, avoiding complex macros. Expect fast compile times, fast runtime, but a tool pedantic about correctness. Its API is less ergonomic.

```rust,editable
{{#include ../../../crates/cats/command_line_interface/examples/arguments/lexopt.rs:example}}
```

### Parse Command-line Arguments with `pico-args` {#pico-args}

[![pico-args][c~pico-args~docs~badge]][c~pico-args~docs]{{hi:pico-args}}
[![pico-args~crates.io][c~pico-args~crates.io~badge]][c~pico-args~crates.io]
[![pico-args~github][c~pico-args~github~badge]][c~pico-args~github]
[![pico-args~lib.rs][c~pico-args~lib.rs~badge]][c~pico-args~lib.rs]

The [`pico-args`][c~pico-args~docs]↗{{hi:pico-args}} crate is a small and fast library for parsing command-line arguments in Rust.

[`pico-args`][c~pico-args~docs]↗{{hi:pico-args}} is tiny, dependency-free, and designed for extremely fast and minimal command-line argument parsing. It focuses on speed and small binary size, making it suitable for resource-constrained environments or applications where performance is critical. It offers a simple API for basic argument parsing but may not be as feature-rich as larger crates. Note the following:

- No help generation.
- Only flags, options, free arguments and subcommands are supported.
- No combined flags (like -vvv or -abc).
- Options can be separated by a space, = (with the `eq-separator` feature) or nothing.
- Arguments can be in any order.
- Non UTF-8 arguments are supported.
- Ergonomic API.

```rust,editable
{{#include ../../../crates/cats/command_line_interface/examples/arguments/pico_args.rs:example}}
```

### Parse Command-line Arguments with `structopt` {#structopt}

[![structopt][c~structopt~docs~badge]][c~structopt~docs] [![structopt~crates.io][c~structopt~crates.io~badge]][c~structopt~crates.io] [![structopt~github][c~structopt~github~badge]][c~structopt~github] [![structopt~lib.rs][c~structopt~lib.rs~badge]][c~structopt~lib.rs]{{hi:structopt}}{{hi:Docopt}}{{hi:Clap}}{{hi:Derive}}{{hi:Cli}} [![cat~command-line-interface][cat~command-line-interface~badge]][cat~command-line-interface]{{hi:Command-line interface}}

[`structopt`][c~structopt~docs]↗{{hi:structopt}} parses command line arguments by defining a [`struct`](https://doc.rust-lang.org/std/keyword.struct.html)↗{{hi:struct}}.

[`structopt`][c~structopt~docs]↗{{hi:structopt}} (now superseded by [`clap`][c~clap~docs]↗{{hi:clap}}) simplifies command-line argument parsing by automatically generating parsers from struct definitions. It leverages a `derive` macro to reduce boilerplate and provides a declarative way to define CLI options, arguments, and subcommands, making it easier to create complex and well-documented command-line interfaces.

## References {#references}

- [Parsing arguments in Rust, without using dependencies][blog~parsing-arguments-rust-no-dep]↗.

## Related Topics {#related-topics}

- [[parse | Parse]].
- [[parser-implementations | Parser Implementations]].
- [[parsing | Parsing]].
- [[string_parsing | String Parsing]].

{{#include refs.incl.md}}
{{#include ../../refs/link-refs.md}}

<div class="hidden">
[arguments: review](https://github.com/john-cd/rust_howto/issues/233)

[Parsing arguments in Rust with no dependencies][blog~parsing-arguments-rust-no-dep].

</div>
